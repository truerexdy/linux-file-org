//Don't assume that this is AI generated by seeing the comments
//I am used to writing comments, it's helps me understand the code better

use std::fs;
use std::env;

fn copy_file(src:&String,dest:&String) {
    match fs::copy(src, dest) {
        Ok(_) => (),
        Err(e) => println!("Unexpected error: {}", e),
    }
}
fn delete_file(file_path: &str) {
    match fs::remove_file(file_path) {
        Ok(_) => (),
        Err(e) => println!("Unexpected error when deleting file '{}': {}", file_path, e),
    }
}
fn main() {
    /*Here I'm declaring a Vec<String> named args to hold the arguements.
    std::env module is used to collece command line arguements*/
    let args: Vec<String> = env::args().collect();
    /*For my case I just need one arguement i.e. the directory path nothing else so
    I will check for that constraint*/
    
    if args.len() != 2{ //2 becaue command itself + the arguement
        println!("Invalid number of command line arguements {}",args.len());
        std::process::exit(0);
        //this is simillar to exit(0) of stdlib in C
    }

    let path: &str = &args[1];
    /*Now this will hold the path of the directory, index is 1 because
    0th index will have the command name itself*/

    let mut files: Vec<String> = Vec::new();
    //A vector of string to hold the file names

    match fs::read_dir(path){
        Ok(entries)=>{ // Entries is a Vec<DirEntry>
            for entry in entries{ //DirEntry is a struct defined in std::fs
                match entry{
                    Ok(entry)=>{
                        files.push(entry.file_name().into_string().unwrap());
                        //unwrap returns string if valid(is UTF-8), Err if invalid(not UTF-8)
                    }
                    Err(e)=>{
                        println!("Error reading the file {}", e);
                    }
                }
            }
        }
        Err(e)=>{
            println!("Error reading directory {} \n {}", path, e);
        }
    }

    /*To Identifying the file types, using the split method for string*/
    let mut filetypes: Vec<String> = Vec::new();

    for file in &files{
        let temp: Vec<&str> = file.split('.').collect();
        if temp.len() > 1 && !filetypes.contains(&temp[1].to_string()){
            filetypes.push(temp[1].to_string());
        }
    }

    for filetype in &filetypes{
        let newdir: String = path.to_string() + "/" + &filetype;
        match fs::create_dir(newdir){
            Ok(result) => result,
            Err(e)=>println!("Error Creating Dir {e}"),
        }
    }

    //Moving the files to their respective dirs
    for file in &files{
        let temp: Vec<&str> = file.split('.').collect();
        if temp.len() > 1{
            let src:String = path.to_string() + "/" + file;
            let dest:String = path.to_string() + "/" + temp[1] + "/"+file;
            copy_file(&src, &dest);
            delete_file(&src);
        }
    }    
    
}
